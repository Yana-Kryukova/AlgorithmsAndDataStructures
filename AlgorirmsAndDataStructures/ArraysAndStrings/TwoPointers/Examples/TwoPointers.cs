namespace Examples
{
    internal class TwoPointers
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello, World!");
        }

        #region Пример 1: дана строка s, верните true если она является палиндромом, false в противном случае.
        // Строка является палиндромом, если она читается одинаково как в прямом, так и в обратном направлении.
        // Это означает, что после перестановки она остаётся той же самой строкой.Например: «abcdcba» или «racecar».

        // Этот алгоритм очень эффективен, поскольку не только выполняется за O(n), 
        // но и использует только  O(1) пространства.Независимо от размера входных данных,
        // мы всегда используем только две целочисленные переменные.Временная сложность составляет O(n),
        // поскольку итерации цикла while стоят O(1) каждая, и их никогда не может быть больше,
        // чем O(n) итераций цикла while - указатели начинаются на расстоянии n друг от друга
        // и сближаются на один шаг каждую итерацию.

        public static bool checkIfPalindrome(string s)
        {
            int left = 0;
            int right = s.Length - 1;

            while (left < right)
            {
                if (s[left] != s[right])
                {
                    return false;
                }

                left++;
                right--;
            }

            return true;
        }
        #endregion

        #region Пример 2. Дано отсортированный массив уникальных целых чисел и целевое целое число. Верните true если существует пара чисел, сумма которых равна целевому числу, false в противном случае.
        // Например, заданные nums = [1, 2, 4, 6, 8, 9, 14, 15] и target = 13 возвращают true, потому что 4 + 9 = 13.
        // Как и в предыдущем примере, этот алгоритм использует пространство O(1) и имеет временную сложность O(n).
        public static bool checkForTarget(int[] nums, int target)
        {
            int left = 0;
            int right = nums.Length - 1;

            while (left < right)
            {
                // curr is the current sum
                int curr = nums[left] + nums[right];
                if (curr == target)
                {
                    return true;
                }

                if (curr > target)
                {
                    right--;
                }
                else
                {
                    left++;
                }
            }

            return false;
        }
        #endregion

        #region Пример 3. Даны два отсортированных массива целых чисел arr1 и arr2, верните новый массив, который объединяет их и также является отсортированным.
        // Как и в двух предыдущих примерах, этот алгоритм имеет временную сложность O(n) и использует O(1) памяти(если не считать вывод дополнительным пространством, что обычно не делается).
        public static int[] combine(int[] arr1, int[] arr2)
        {
            // ans is the answer
            int[] ans = new int[arr1.Length + arr2.Length];
            int i = 0;
            int j = 0;
            int k = 0;

            while (i < arr1.Length && j < arr2.Length)
            {
                if (arr1[i] < arr2[j])
                {
                    ans[k] = arr1[i];
                    i++;
                }
                else
                {
                    ans[k] = arr2[j];
                    j++;
                }
                k++;
            }
            // Обратите внимание на то, что использование цикла for приводит к более лаконичной записи
            while (i < arr1.Length) ans[k++] = arr1[i++];

            for (; j < arr2.Length; ans[k++] = arr1[j++]) ;

            return ans;
        }
        #endregion

        #region Пример 4: Является подпоследовательностью. Даны две строки s и t.Верните true если s является подпоследовательностью t, или false в противном случае.
        // Подпоследовательность строки — это последовательность символов, которую можно получить, удалив некоторые (или все) символы из исходной строки, сохранив при этом относительный порядок оставшихся символов.Например, «ace» является подпоследовательностью «abcde», а «aec» — нет.

        // Как и во всех предыдущих примерах, в этом решении используется O(1) памяти.Временная сложность линейно зависит от длин s и t.
        public static bool isSubsequence(string s, string t)
        {
            int i = 0;
            int j = 0;

            while (i < s.Length && j < t.Length)
            {
                if (s[i] == t[j])
                {
                    i++;
                }
                j++;
            }

            return i == s.Length;
        }

        #endregion
    }
}
